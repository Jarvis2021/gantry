# -----------------------------------------------------------------------------
# PROJECT IDENTITY: GANTRY (The "Fleet" Protocol)
# -----------------------------------------------------------------------------
# Core Concept:
# Gantry is a headless, voice-activated software factory. It allows a Chief Architect
# (driving) to spin up ephemeral "Project Pods" (Docker containers) to build,
# audit, and deploy software artifacts without touching a keyboard.
#
# The Gantry Guarantee (Zero-Trust):
# 1. "No Touch" Build: Code is generated and run inside isolated Project Pods.
# 2. "Green Light" Deploy: Code is only pushed if the Critic Agent passes audits.
# 3. "Black Box" Evidence: Every mission records a cryptographic audit trail.
#
# Technical Stack:
# - Brain: AWS Bedrock (Claude 3.5 Sonnet) via IAM Roles.
# - Body: Docker (via Secure Proxy).
# - Uplink: Cloudflare Tunnel.
# - Storage: PostgreSQL (Connection Pooled).
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# 1. SECURITY & SAFETY (NON-NEGOTIABLE)
# -----------------------------------------------------------------------------
- PROXY PROTOCOL:
  - NEVER connect to `/var/run/docker.sock` directly.
  - ALWAYS connect via `tcp://docker-proxy:2375`.
- DEAD MAN'S SWITCH:
  - Every Project Pod must have a hard TTL (180 seconds).
  - If a build hangs, the Watchdog thread must kill it.
- IAM AUTHENTICATION:
  - Do NOT use hardcoded AWS keys. Use the Default Credential Chain.
- **SECRETS POLICY (CRITICAL)**:
  - NEVER commit secrets, API keys, tokens, or credentials to git.
  - NEVER reference user's work profiles, account IDs, or employer details.
  - NEVER include AWS account numbers, profile names, or ARNs in committed code.
  - ALL sensitive values MUST use placeholders (e.g., YOUR_API_KEY, YOUR_PROFILE).
  - Store secrets ONLY in .env files (which are gitignored).
  - Before ANY git commit, scan for: API keys, tokens, account IDs, profile names.

# -----------------------------------------------------------------------------
# 2. HEADLESS UX (DRIVER SAFETY)
# -----------------------------------------------------------------------------
- AUDIO FEEDBACK:
  - Every API response must include a `speech` field for TTS.
  - Keep speech concise: "Gantry copying. Pod launched." (Not verbose).

# -----------------------------------------------------------------------------
# 3. CODING STANDARDS
# -----------------------------------------------------------------------------
- Use `pydantic` for all Manifests.
- Use `psycopg2` with `SimpleConnectionPool` for Database.
- Use `rich` for all console output.
- Wrap all external calls (AWS/Docker) in try/except blocks.

# -----------------------------------------------------------------------------
# 4. HEADLESS PROTOCOL (DRIVER SAFETY)
# -----------------------------------------------------------------------------
- AUDIO FIRST: Every API response MUST include a `speech` field with concise,
  natural language text for TTS engines (e.g., iOS Shortcuts).
- BLACK BOX LOGGING:
  - Every mission MUST create a dedicated folder: `missions/{mission_id}/`.
  - REQUIRED ARTIFACTS: `flight_recording.json`, `manifest.json`, `audit_report.json`.
  - The system must write these files *even if the mission fails*.

# -----------------------------------------------------------------------------
# 5. RESOURCE SAFETY (DEAD MAN'S SWITCH)
# -----------------------------------------------------------------------------
- TIME-TO-LIVE (TTL):
  - Sibling containers must ALWAYS be spawned with a strict timeout or be
    monitored by a watchdog thread.
  - HARD LIMIT: 180 seconds (3 minutes) per build. Kill the container if exceeded.
- RESOURCE LIMITS:
  - Docker containers must specify `mem_limit="512m"` to prevent memory leaks.

# -----------------------------------------------------------------------------
# 6. CLOUD SECURITY (AWS IAM)
# -----------------------------------------------------------------------------
- NO LONG-TERM KEYS:
  - Do NOT use `AWS_ACCESS_KEY_ID` or `AWS_SECRET_ACCESS_KEY` environment variables.
  - Rely on the EC2/Container Instance Role (Default Credential Provider Chain).
  - Initialize boto3 clients simply as `boto3.client("bedrock-runtime", region_name="us-east-1")`
    without passing explicit keys.

# -----------------------------------------------------------------------------
# 7. DOCUMENTATION
# -----------------------------------------------------------------------------
- Every major module (`architect.py`, `foundry.py`, `fleet.py`) must have a top-level comment describing its responsibility in the Fleet.
- Update the README.md whenever a new dependency is added.
- **STRICT: NEVER create new .md files without explicit user approval.** Ask first.

# -----------------------------------------------------------------------------
# 8. DEPLOYMENT (VERCEL CLI)
# -----------------------------------------------------------------------------
- REAL URL REQUIREMENT:
  - Every successful mission MUST result in a live HTTP endpoint.
  - Use `vercel-cli` for instant deployments.
  - COMMAND: `vercel deploy --prod --token $VERCEL_TOKEN --yes`
  - CAPTURE: The stdout contains the Production URL. Parse it.
- BUILDER IMAGE:
  - Use `gantry/builder:latest` for all Project Pods.
  - Image includes: Python 3.11, Node.js 20, Git, Vercel CLI.
  - Pass VERCEL_TOKEN securely from host environment.

# -----------------------------------------------------------------------------
# 9. GIT SAFETY (JUNIOR DEV MODEL)
# -----------------------------------------------------------------------------
# Gantry operates like a Junior Developer - it proposes, YOU approve.
#
- **NEVER PUSH TO MAIN**:
  - NEVER push directly to `main` or `master` branch.
  - ALWAYS create a unique feature branch: `feat/{project}-{short_id}`.
  - ALWAYS open a Pull Request (PR) for human review.
- **PR WORKFLOW**:
  - Create branch → Push branch → Open PR via GitHub API.
  - PR Title: "Gantry Mission: {project_name}"
  - PR Body: Include audit status and evidence path.
  - Return the PR URL for review notification.
- **WHY**: This prevents accidental secret leaks and maintains human oversight.
  Gantry is your Staff Engineer; YOU remain the Lead.

# -----------------------------------------------------------------------------
# 10. CODE QUALITY CRITIC LAYER (STRICT ENFORCEMENT)
# -----------------------------------------------------------------------------
# Before writing or modifying ANY code, apply these quality gates:
#
- **DRY (Don't Repeat Yourself)**:
  - NEVER duplicate code. Extract common logic into functions/classes.
  - If you see similar code blocks, REFACTOR immediately.
  - Use helper functions, base classes, and composition.
- **TIME COMPLEXITY**:
  - Always consider Big-O complexity.
  - Avoid O(n²) when O(n) is possible. Document complexity in comments.
  - Use appropriate data structures (dict for O(1) lookup, not list).
- **STRICT LINTING**:
  - Run `read_lints` BEFORE declaring any code complete.
  - Zero linting errors allowed. Fix all warnings.
  - Follow PEP 8 for Python, ESLint rules for JS/TS.
- **PYDANTIC MODELS**:
  - ALL data structures must use Pydantic models.
  - No raw dicts for structured data. Define proper schemas.
  - Use validators for complex fields.
- **SYSTEM DESIGN PRINCIPLES**:
  - Single Responsibility: Each class/function does ONE thing.
  - Open/Closed: Open for extension, closed for modification.
  - Dependency Injection: Pass dependencies, don't hardcode.
  - Separation of Concerns: Keep layers distinct (API, Core, Infra).
- **ARCHITECTURE PATTERNS**:
  - Follow existing patterns in codebase. Don't introduce new ones without reason.
  - Use the established folder structure: `src/core/`, `src/infra/`, `src/domain/`.
  - Interfaces before implementations.
- **NO CODE BLOAT**:
  - Every line must have a purpose. Delete dead code.
  - Prefer composition over inheritance.
  - Keep functions under 50 lines. Split if longer.
  - Maximum 3 levels of nesting. Flatten with early returns.
- **ERROR HANDLING**:
  - Never swallow exceptions. Log them at minimum.
  - Use specific exception types, not bare `except:`.
  - Fail fast with clear error messages.

# -----------------------------------------------------------------------------
# 11. DEFINITION OF DONE (STRICT ENFORCEMENT)
# -----------------------------------------------------------------------------
# A task is NOT complete until ALL of the following are verified:
#
- **NO UNTESTED CODE**: Never declare code "complete" or "ready" without running tests.
- **VERIFY BEFORE CONFIRM**: Execute the code, observe the output, confirm it works.
- **ALL RULES APPLY**: Every rule in this file must be followed. No exceptions.
- **SAY "READY" ONLY WHEN TESTED**: The words "done", "complete", or "ready" are 
  FORBIDDEN until tests have passed and functionality is confirmed.
#
# Workflow Checklist (Must complete in order):
# 1. Write/modify code following all standards above.
# 2. Run linter checks (read_lints).
# 3. Execute tests or manual verification.
# 4. Observe output and confirm expected behavior.
# 5. ONLY THEN may you declare the task complete.
#
# If testing is not possible (e.g., requires external service), explicitly state:
# "PENDING VERIFICATION: [reason]" — never claim completion.

# -----------------------------------------------------------------------------
# 12. PROTOTYPING STRATEGY FOR LARGER WEBSITES (RESOURCE OPTIMIZATION)
# -----------------------------------------------------------------------------
# When building "larger websites" or "big website prototypes":
#
- **BUILD IN PHASES**: Start with a lighter prototype, deploy, verify, then iterate.
- **NO ORM IN PROTOTYPES**: Gantry deploys to serverless (Vercel) without databases.
  - Use localStorage for client-side persistence
  - Use JSON files or mock APIs for initial data
  - Advise users they can add Supabase/PlanetScale/MongoDB later
- **PROGRESSIVE ENHANCEMENT**:
  1. Phase 1: Static UI with mock data (quick to build & deploy)
  2. Phase 2: Add interactivity with localStorage
  3. Phase 3: Connect to external services (user adds API keys)
- **RESOURCE AWARENESS**:
  - Build times are limited to 180 seconds
  - Container memory is 512MB
  - Suggest breaking complex apps into microservices
- **CONSULTATION GUIDANCE**:
  - When user asks for "database", "user accounts", or "big website":
    - Explain we'll build a working prototype first
    - Mention they can add a real database after deployment
    - Offer to structure code for easy DB integration later
- **EXAMPLE RESPONSE**:
  "I'll build a working LinkedIn clone prototype using localStorage for data. 
   After we verify it's deployed and working, you can connect it to Supabase 
   for real user accounts. This approach ensures we deliver fast and avoid 
   resource timeouts. Shall I proceed?"

# -----------------------------------------------------------------------------
# 13. ARCHITECTURE v2.0 PATTERNS (REQUIRED)
# -----------------------------------------------------------------------------
# The codebase has been upgraded to v2.0 architecture. Follow these patterns:
#
- **FASTAPI OVER FLASK**:
  - Use `main_fastapi.py` as the primary entrypoint.
  - All new endpoints must be async (`async def`).
  - Use dependency injection via `Depends()`.
  - Leverage auto-generated OpenAPI docs at `/docs`.
- **WEBSOCKET FOR REAL-TIME**:
  - Use WebSocket (`/gantry/ws/{mission_id}`) for status updates.
  - Broadcast via `ConnectionManager.broadcast()`.
  - Never rely on HTTP polling for real-time updates.
- **ARGON2 FOR PASSWORDS**:
  - Use `auth_v2.py` with Argon2 password hashing.
  - NEVER use SHA256, MD5, or other weak hashing.
  - Support pre-hashed passwords via `GANTRY_PASSWORD_HASH` env var.
- **TOKEN BUCKET RATE LIMITING**:
  - Apply per-user rate limiting with TokenBucket (not just per-IP).
  - Both `RateLimiter` (IP) and `TokenBucket` (user) must be used.
- **PLUGGABLE SKILLS**:
  - New AI capabilities go in `src/skills/{skill-name}/`.
  - Each skill has: `handler.py`, `__init__.py`, `SKILL.md`.
  - Skills auto-load at startup via `SkillRegistry.load_all()`.
  - Never hardcode skills in architect.py.
- **EXTERNAL PROMPTS**:
  - AI prompts live in `prompts/*.md` files.
  - Load with `_load_prompt("name")` pattern.
  - Never embed 50+ line prompts in Python code.
- **SPLIT FUNCTIONS**:
  - Use `fleet_v2.py` pattern: split long functions into phases.
  - Each phase function: `_phase_architect()`, `_phase_build()`, etc.
  - Maximum 50 lines per function enforced.

# -----------------------------------------------------------------------------
# 14. FILE NAMING CONVENTIONS
# -----------------------------------------------------------------------------
- **V2 MODULES**: New architecture files use `_v2` suffix during migration:
  - `auth_v2.py`, `fleet_v2.py`, `main_fastapi.py`
  - After migration complete, these become the primary files.
- **SKILLS**: `src/skills/{skill-name}/handler.py`
- **PROMPTS**: `prompts/{prompt-name}.md`
- **TESTS**: `tests/test_{module}.py`
